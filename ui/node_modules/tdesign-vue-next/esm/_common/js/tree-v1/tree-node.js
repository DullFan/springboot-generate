/**
 * tdesign v1.9.4
 * (c) 2024 tdesign
 * @license MIT
 */

import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import isNull from 'lodash/isNull';
import isFunction from 'lodash/isFunction';
import isNumber from 'lodash/isNumber';
import uniqueId from 'lodash/uniqueId';
import isBoolean from 'lodash/isBoolean';
import isNil from 'lodash/isNil';
import get from 'lodash/get';
import { createNodeModel, updateNodeModel } from './tree-node-model.js';
import '../log/index.js';
import log from '../log/log.js';
import 'lodash/isUndefined';
import 'lodash/pick';
import 'lodash/omit';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var hasOwnProperty = Object.prototype.hasOwnProperty;
var setableStatus = {
  expandMutex: null,
  activable: null,
  checkable: null,
  draggable: null,
  loading: false
};
var setableProps = Object.keys(setableStatus);
var syncableProps = [].concat(setableProps, ["actived", "expanded", "checked"]);
var privateKey = "__tdesign_id__";
var TreeNode = /*#__PURE__*/function () {
  function TreeNode(tree, data, parent) {
    var _this = this;
    _classCallCheck(this, TreeNode);
    _defineProperty(this, "tree", void 0);
    _defineProperty(this, "value", void 0);
    _defineProperty(this, "label", void 0);
    _defineProperty(this, "data", void 0);
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "children", void 0);
    _defineProperty(this, "model", void 0);
    _defineProperty(this, "vmIsLeaf", void 0);
    _defineProperty(this, "vmIsFirst", void 0);
    _defineProperty(this, "vmIsLast", void 0);
    _defineProperty(this, "vmIsRest", void 0);
    _defineProperty(this, "vmIsLocked", void 0);
    _defineProperty(this, "expanded", void 0);
    _defineProperty(this, "expandMutex", void 0);
    _defineProperty(this, "actived", void 0);
    _defineProperty(this, "activable", void 0);
    _defineProperty(this, "checkable", void 0);
    _defineProperty(this, "vmCheckable", void 0);
    _defineProperty(this, "checked", void 0);
    _defineProperty(this, "indeterminate", void 0);
    _defineProperty(this, "disabled", void 0);
    _defineProperty(this, "draggable", void 0);
    _defineProperty(this, "visible", void 0);
    _defineProperty(this, "level", void 0);
    _defineProperty(this, "loading", void 0);
    this.data = data;
    this.tree = tree;
    var config = tree.config || {};
    var prefix = config.prefix || "t";
    var keys = config.keys || {};
    var propChildren = keys.children || "children";
    var propLabel = keys.label || "label";
    var propValue = keys.value || "value";
    var propsDisabled = keys.disabled || "disabled";
    this.model = null;
    this.children = null;
    this.level = 0;
    this.vmCheckable = false;
    this.vmIsLeaf = false;
    this.vmIsFirst = false;
    this.vmIsLast = false;
    this.vmIsRest = false;
    this.vmIsLocked = false;
    this.visible = false;
    this.actived = false;
    this.checked = false;
    this.indeterminate = false;
    this.loading = false;
    this.expanded = config.expandAll;
    this.activable = null;
    this.checkable = null;
    this.expandMutex = null;
    this.draggable = null;
    this[privateKey] = uniqueId(prefix);
    this.value = isNil(get(data, propValue)) ? this[privateKey] : get(data, propValue);
    var nodeMap = tree.nodeMap,
      privateMap = tree.privateMap;
    if (nodeMap.get(this.value)) {
      log.warn("Tree", "Dulplicate value: ".concat(this.value));
    }
    nodeMap.set(this.value, this);
    privateMap.set(this[privateKey], this);
    this.label = get(data, propLabel) || "";
    this.disabled = get(data, propsDisabled);
    var children = data[propChildren];
    if (children === true) {
      this.children = children;
    }
    if (parent && parent instanceof TreeNode) {
      this.parent = parent;
    } else {
      this.parent = null;
    }
    syncableProps.forEach(function (prop) {
      if (typeof data[prop] !== "undefined") {
        _this[prop] = data[prop];
      }
    });
    this.initActived();
    this.initExpanded();
    this.initChecked();
    if (Array.isArray(children)) {
      this.append(children);
    } else if (children === true && !config.lazy) {
      this.loadChildren();
    }
    this.updateChecked();
    this.update();
    tree.reflow(this);
  }
  return _createClass(TreeNode, [{
    key: "initChecked",
    value: function initChecked() {
      var tree = this.tree,
        value = this.value,
        parent = this.parent;
      var checkedMap = tree.checkedMap;
      var checkStrictly = tree.config.checkStrictly;
      if (this.checked) {
        checkedMap.set(value, true);
      }
      if (!checkStrictly && parent !== null && parent !== void 0 && parent.isChecked()) {
        checkedMap.set(value, true);
      }
      this.updateChecked();
    }
  }, {
    key: "initExpanded",
    value: function initExpanded() {
      var tree = this.tree;
      var expanded = this.expanded;
      var config = tree.config;
      if (isNumber(config.expandLevel) && this.getLevel() < config.expandLevel) {
        tree.expandedMap.set(this.value, true);
        expanded = true;
      }
      if (this.children === true && config.lazy) {
        expanded = false;
      }
      if (expanded) {
        tree.expandedMap.set(this.value, true);
      } else {
        tree.expandedMap["delete"](this.value);
      }
      this.expanded = expanded;
    }
  }, {
    key: "initActived",
    value: function initActived() {
      var tree = this.tree,
        actived = this.actived;
      if (actived && this.isActivable()) {
        tree.activedMap.set(this.value, true);
      }
    }
  }, {
    key: "append",
    value: function append(data) {
      var _this2 = this;
      var list = [];
      if (!Array.isArray(data)) {
        list.push(data);
      } else {
        list.push.apply(list, _toConsumableArray(data));
      }
      if (list.length <= 0) {
        return;
      }
      if (!Array.isArray(this.children)) {
        this.children = [];
      }
      var children = this.children,
        tree = this.tree;
      list.forEach(function (item) {
        var node = null;
        if (item instanceof TreeNode) {
          node = item;
          node.appendTo(_this2.tree, _this2);
        } else {
          node = new TreeNode(_this2.tree, item, _this2);
          children.push(node);
        }
      });
      tree.reflow(this);
      this.updateRelated();
    }
  }, {
    key: "appendTo",
    value: function appendTo(tree, parent, index) {
      var _this3 = this;
      var parentNode = parent;
      var targetIndex = -1;
      if (isNumber(index)) {
        targetIndex = index;
      }
      var targetParents = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.getParents()) || [];
      var includeCurrent = targetParents.some(function (pnode) {
        return pnode === _this3;
      });
      if (includeCurrent) {
        throw new Error("\u65E0\u6CD5\u5C06\u7236\u8282\u70B9\u63D2\u5165\u5230\u5B50\u8282\u70B9");
      }
      if (parentNode === this) {
        throw new Error("\u65E0\u6CD5\u5C06\u8282\u70B9\u63D2\u5165\u5230\u672C\u8282\u70B9");
      }
      if (Array.isArray(parentNode === null || parentNode === void 0 ? void 0 : parentNode.children)) {
        var targetPosNode = parentNode === null || parentNode === void 0 ? void 0 : parentNode.children[targetIndex];
        if (targetPosNode && targetPosNode === this) {
          return;
        }
      }
      var siblings = null;
      if (parentNode instanceof TreeNode) {
        if (!Array.isArray(parentNode === null || parentNode === void 0 ? void 0 : parentNode.children)) {
          parentNode.children = [];
        }
        siblings = parent.children;
      } else {
        siblings = tree.children;
      }
      if (!Array.isArray(siblings)) {
        throw new Error("\u65E0\u6CD5\u63D2\u5165\u5230\u76EE\u6807\u4F4D\u7F6E\uFF0C\u53EF\u63D2\u5165\u7684\u8282\u70B9\u5217\u8868\u4E0D\u5B58\u5728");
      }
      var prevLength = siblings.length;
      var prevIndex = this.getIndex();
      this.remove();
      if (isNumber(index)) {
        var targetIndex2 = index;
        if (parentNode === this.parent) {
          var curLength = siblings.length;
          if (curLength < prevLength && prevIndex <= targetIndex2) {
            targetIndex2 -= 1;
          }
        }
        siblings.splice(targetIndex2, 0, this);
      } else {
        siblings.push(this);
      }
      this.parent = parentNode;
      var nodes = this.walk();
      nodes.forEach(function (item) {
        var node = item;
        node.tree = tree;
        tree.nodeMap.set(node.value, node);
        tree.privateMap.set(node[privateKey], node);
        if (node.expanded) {
          tree.expandedMap.set(node.value, true);
        }
      });
      var updateNodes = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.walk()) || tree.children.map(function (item) {
        return item.walk();
      }).flat();
      updateNodes.forEach(function (node) {
        node.update();
        node.updateChecked();
      });
      tree.reflow();
    }
  }, {
    key: "insert",
    value: function insert(item, index) {
      var tree = this.tree,
        parent = this.parent;
      var siblings = this.getSiblings();
      var node = null;
      if (item instanceof TreeNode) {
        node = item;
        node.appendTo(tree, parent, index);
      } else if (item) {
        node = new TreeNode(tree, item, parent);
        if (isNumber(index)) {
          siblings.splice(index, 0, node);
        }
        siblings.forEach(function (sibling) {
          sibling.update();
        });
      }
      tree.reflow();
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newData) {
      var index = this.getIndex();
      this.insert(newData, index);
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(newData) {
      var index = this.getIndex();
      this.insert(newData, index + 1);
    }
  }, {
    key: "remove",
    value: function remove() {
      var tree = this.tree;
      var nodes = this.walk();
      var siblings = this.getSiblings();
      var index = this.getIndex();
      if (Array.isArray(siblings)) {
        siblings.splice(index, 1);
      }
      nodes.forEach(function (node) {
        node.clean();
      });
      siblings.forEach(function (node) {
        node.update();
      });
      this.updateParents();
      tree.reflow();
    }
  }, {
    key: "clean",
    value: function clean() {
      var tree = this.tree,
        value = this.value;
      tree.activedMap["delete"](value);
      tree.checkedMap["delete"](value);
      tree.expandedMap["delete"](value);
      tree.nodeMap["delete"](value);
      tree.filterMap["delete"](value);
      tree.privateMap["delete"](this[privateKey]);
    }
  }, {
    key: "loadChildren",
    value: function () {
      var _loadChildren = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var config, list;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              config = get(this, "tree.config") || {};
              if (!(this.children === true && !this.loading)) {
                _context.next = 13;
                break;
              }
              if (!isFunction(config.load)) {
                _context.next = 13;
                break;
              }
              this.loading = true;
              this.update();
              list = [];
              _context.next = 8;
              return config.load(this);
            case 8:
              list = _context.sent;
              this.tree.emit("load", {
                node: this,
                data: list
              });
              this.loading = false;
              if (Array.isArray(list) && list.length > 0) {
                this.append(list);
              } else {
                this.children = false;
              }
              this.update();
            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function loadChildren() {
        return _loadChildren.apply(this, arguments);
      }
      return loadChildren;
    }()
  }, {
    key: "set",
    value: function set(item) {
      var _this4 = this;
      var tree = this.tree;
      var keys = Object.keys(item);
      keys.forEach(function (key) {
        if (hasOwnProperty.call(setableStatus, key) || key === "label" || key === "disabled") {
          _this4[key] = item[key];
        }
      });
      tree.updated(this);
    }
  }, {
    key: "getParent",
    value: function getParent() {
      return this.parent;
    }
  }, {
    key: "getParents",
    value: function getParents() {
      var parents = [];
      var node = this.parent;
      while (node) {
        parents.push(node);
        node = node.parent;
      }
      return parents;
    }
  }, {
    key: "getSiblings",
    value: function getSiblings() {
      var parent = this.parent,
        tree = this.tree;
      var list = [];
      if (parent) {
        if (Array.isArray(parent.children)) {
          list = parent.children;
        }
      } else if (tree) {
        list = tree.children;
      }
      return list;
    }
  }, {
    key: "getChildren",
    value: function getChildren(deep) {
      var childrenModel = false;
      var children = this.children;
      if (Array.isArray(children)) {
        if (children.length > 0) {
          if (deep) {
            var nodes = this.walk();
            nodes.shift();
            childrenModel = nodes.map(function (item) {
              return item.getModel();
            });
          } else {
            childrenModel = children.map(function (item) {
              return item.getModel();
            });
          }
        } else {
          childrenModel = false;
        }
      } else if (isBoolean(children)) {
        childrenModel = children;
      }
      return childrenModel;
    }
  }, {
    key: "getRoot",
    value: function getRoot() {
      var parents = this.getParents();
      return parents[parents.length - 1] || null;
    }
  }, {
    key: "getIndex",
    value: function getIndex() {
      var list = this.getSiblings();
      return list.indexOf(this);
    }
  }, {
    key: "getPath",
    value: function getPath() {
      var nodes = this.getParents();
      nodes.unshift(this);
      return nodes.reverse();
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      var parents = this.getParents();
      return parents.length;
    }
  }, {
    key: "isRest",
    value: function isRest() {
      var _this$tree = this.tree,
        config = _this$tree.config,
        filterMap = _this$tree.filterMap,
        hasFilter = _this$tree.hasFilter;
      var rest = false;
      if (hasFilter) {
        var nodeModel = this.getModel();
        rest = config.filter(nodeModel);
      }
      if (rest) {
        filterMap.set(this.value, true);
      } else if (filterMap.get(this.value)) {
        filterMap["delete"](this.value);
      }
      return rest;
    }
  }, {
    key: "isVisible",
    value: function isVisible() {
      var _this$tree2 = this.tree,
        nodeMap = _this$tree2.nodeMap,
        hasFilter = _this$tree2.hasFilter,
        config = _this$tree2.config;
      var allowFoldNodeOnFilter = config.allowFoldNodeOnFilter;
      var visible = true;
      if (!nodeMap.get(this.value)) {
        return false;
      }
      if (hasFilter && !allowFoldNodeOnFilter) {
        visible = this.vmIsLocked || this.vmIsRest;
        return visible;
      }
      var expandVisible = true;
      var parents = this.getParents();
      if (parents.length > 0) {
        expandVisible = parents.every(function (node) {
          return node.expanded;
        });
      }
      if (hasFilter) {
        visible = expandVisible && (this.vmIsRest || this.vmIsLocked);
      } else {
        visible = expandVisible;
      }
      return visible;
    }
  }, {
    key: "isDisabled",
    value: function isDisabled() {
      var tree = this.tree;
      var hasFilter = tree.hasFilter,
        config = tree.config;
      var disabled = config.disabled,
        allowFoldNodeOnFilter = config.allowFoldNodeOnFilter;
      if (hasFilter && !allowFoldNodeOnFilter && this.vmIsLocked && !this.vmIsRest) {
        return true;
      }
      var state = disabled;
      if (typeof this.disabled === "boolean") {
        state = this.disabled;
      }
      return state;
    }
  }, {
    key: "isDraggable",
    value: function isDraggable() {
      var state = !!get(this, "tree.config.draggable");
      if (typeof this.draggable === "boolean") {
        state = this.draggable;
      }
      return state;
    }
  }, {
    key: "isExpandMutex",
    value: function isExpandMutex() {
      var state = !!get(this, "tree.config.expandMutex");
      if (typeof this.expandMutex === "boolean") {
        state = this.expandMutex;
      }
      return state;
    }
  }, {
    key: "isActivable",
    value: function isActivable() {
      var state = !!get(this, "tree.config.activable");
      if (typeof this.activable === "boolean") {
        state = this.activable;
      }
      return state;
    }
  }, {
    key: "isCheckable",
    value: function isCheckable() {
      var state = !!get(this, "tree.config.checkable");
      if (typeof this.checkable === "boolean") {
        state = this.checkable;
      }
      return state;
    }
  }, {
    key: "isActived",
    value: function isActived(map) {
      var tree = this.tree,
        value = this.value;
      var activedMap = map || tree.activedMap;
      return !!(tree.nodeMap.get(value) && activedMap.get(value));
    }
  }, {
    key: "isExpanded",
    value: function isExpanded(map) {
      var tree = this.tree,
        value = this.value,
        vmIsLocked = this.vmIsLocked;
      var hasFilter = tree.hasFilter,
        config = tree.config;
      var allowFoldNodeOnFilter = config.allowFoldNodeOnFilter;
      if (hasFilter && !allowFoldNodeOnFilter && vmIsLocked) return true;
      var expandedMap = map || tree.expandedMap;
      return !!(tree.nodeMap.get(value) && expandedMap.get(value));
    }
  }, {
    key: "isChecked",
    value: function isChecked(map) {
      var children = this.children,
        tree = this.tree,
        value = this.value;
      var checkStrictly = tree.config.checkStrictly;
      if (!tree.nodeMap.get(value)) return false;
      if (!this.isCheckable()) return false;
      var checkedMap = map || tree.checkedMap;
      var checked = false;
      if (checkedMap.get(value)) {
        return true;
      }
      if (checkStrictly) return checked;
      if (Array.isArray(children) && children.length > 0) {
        checked = children.every(function (node) {
          var childIsChecked = node.isChecked(checkedMap);
          return childIsChecked;
        });
      } else {
        var parents = this.getParents();
        checked = parents.some(function (node) {
          return checkedMap.get(node.value);
        });
      }
      return checked;
    }
  }, {
    key: "isIndeterminate",
    value: function isIndeterminate() {
      var children = this.children,
        tree = this.tree,
        value = this.value;
      var checkStrictly = tree.config.checkStrictly;
      if (!tree.nodeMap.get(value)) return false;
      if (!this.isCheckable()) return false;
      if (checkStrictly) return false;
      if (!Array.isArray(children)) return false;
      var childChecked = null;
      var indeterminate = children.some(function (node) {
        if (node.isIndeterminate()) {
          return true;
        }
        if (isNull(childChecked)) {
          childChecked = node.isChecked();
        }
        if (childChecked !== node.isChecked()) {
          return true;
        }
        return false;
      });
      return indeterminate;
    }
  }, {
    key: "isFirst",
    value: function isFirst() {
      var siblings = this.getSiblings();
      return siblings[0] === this;
    }
  }, {
    key: "isLast",
    value: function isLast() {
      var siblings = this.getSiblings();
      return siblings[siblings.length - 1] === this;
    }
  }, {
    key: "isLeaf",
    value: function isLeaf() {
      var isLeaf = false;
      if (Array.isArray(this.children)) {
        isLeaf = this.children.length <= 0;
      } else {
        isLeaf = !this.children;
      }
      return isLeaf;
    }
  }, {
    key: "lock",
    value: function lock(lockState) {
      this.vmIsLocked = lockState;
      this.expanded = this.isExpanded();
      this.visible = this.isVisible();
    }
  }, {
    key: "afterExpanded",
    value: function afterExpanded() {
      this.update();
      if (this.expanded && this.children === true) {
        this.loadChildren();
      }
      this.updateChildren();
    }
  }, {
    key: "toggleExpanded",
    value: function toggleExpanded() {
      return this.setExpanded(!this.isExpanded());
    }
  }, {
    key: "setExpanded",
    value: function setExpanded(expanded, opts) {
      var tree = this.tree;
      var config = tree.config;
      var options = _objectSpread({
        directly: false
      }, opts);
      var map = tree.expandedMap;
      if (!options.directly) {
        map = new Map(tree.expandedMap);
      }
      if (expanded) {
        var shouldExpandNodes = [];
        shouldExpandNodes.push(this);
        if (config.expandParent) {
          this.getParents().forEach(function (node) {
            shouldExpandNodes.push(node);
          });
        }
        shouldExpandNodes.forEach(function (node) {
          var isExpandMutex = false;
          if (node.parent) {
            isExpandMutex = node.parent.isExpandMutex();
          } else {
            var _tree$config;
            isExpandMutex = tree === null || tree === void 0 || (_tree$config = tree.config) === null || _tree$config === void 0 ? void 0 : _tree$config.expandMutex;
          }
          if (isExpandMutex) {
            var siblings = node.getSiblings();
            siblings.forEach(function (snode) {
              map["delete"](snode.value);
              snode.update();
              snode.updateChildren();
            });
          }
          map.set(node.value, true);
          node.update();
          node.updateChildren();
        });
      } else {
        map["delete"](this.value);
      }
      if (options.directly) {
        this.afterExpanded();
      }
      return tree.getExpanded(map);
    }
  }, {
    key: "toggleActived",
    value: function toggleActived() {
      return this.setActived(!this.isActived());
    }
  }, {
    key: "setActived",
    value: function setActived(actived, opts) {
      var tree = this.tree;
      var options = _objectSpread({
        directly: false
      }, opts);
      var config = tree.config || {};
      var map = tree.activedMap;
      if (!options.directly) {
        map = new Map(tree.activedMap);
      }
      if (this.isActivable()) {
        if (actived) {
          var prevKeys = Array.from(map.keys());
          if (!config.activeMultiple) {
            map.clear();
          }
          prevKeys.forEach(function (value) {
            var node = tree.getNode(value);
            node === null || node === void 0 || node.update();
          });
          map.set(this.value, true);
        } else {
          map["delete"](this.value);
        }
      }
      this.update();
      return tree.getActived(map);
    }
  }, {
    key: "toggleChecked",
    value: function toggleChecked() {
      return this.setChecked(!this.isChecked());
    }
  }, {
    key: "setChecked",
    value: function setChecked(checked, opts) {
      var tree = this.tree;
      var config = tree.config || {};
      var options = _objectSpread({
        isAction: true,
        directly: false
      }, opts);
      var map = tree.checkedMap;
      if (!options.directly) {
        map = new Map(tree.checkedMap);
      }
      if (!this.isCheckable()) {
        return tree.getChecked(map);
      }
      if (options.isAction && this.isDisabled()) {
        return tree.getChecked(map);
      }
      if (checked === this.isChecked()) {
        return tree.getChecked(map);
      }
      if (checked) {
        map.set(this.value, true);
      } else {
        map["delete"](this.value);
      }
      if (config.checkStrictly) {
        if (options.directly) {
          this.updateChecked();
        }
      } else {
        this.spreadChildrenChecked(checked, map, options);
        this.spreadParentChecked(checked, map, options);
        if (options.directly) {
          var relatedNodes = tree.getRelatedNodes([this.value], {
            reverse: true
          });
          relatedNodes.forEach(function (node) {
            node.updateChecked();
          });
        }
      }
      return tree.getChecked(map);
    }
  }, {
    key: "spreadParentChecked",
    value: function spreadParentChecked(checked, map, opts) {
      var options = _objectSpread({
        isAction: true,
        directly: false
      }, opts);
      if (!this.isCheckable()) return;
      var children = this.children;
      if (Array.isArray(children) && children.length > 0) {
        map["delete"](this.value);
      }
      var parent = this.parent;
      if (!parent) return;
      parent.spreadParentChecked(checked, map, options);
    }
  }, {
    key: "spreadChildrenChecked",
    value: function spreadChildrenChecked(checked, map, opts) {
      var options = _objectSpread({
        isAction: true,
        directly: false
      }, opts);
      if (!this.isCheckable()) return;
      if (options.isAction && this.isDisabled()) return;
      var children = this.children;
      if (!Array.isArray(children)) return;
      children.forEach(function (node) {
        if (options.isAction && node.isDisabled()) return;
        if (checked) {
          map.set(node.value, true);
        } else {
          map["delete"](node.value);
        }
        node.spreadChildrenChecked(checked, map, options);
      });
    }
  }, {
    key: "update",
    value: function update() {
      this.level = this.getLevel();
      this.vmIsFirst = this.isFirst();
      this.vmIsLast = this.isLast();
      this.vmIsLeaf = this.isLeaf();
      this.vmCheckable = this.isCheckable();
      this.vmIsRest = this.isRest();
      this.actived = this.isActived();
      this.expanded = this.isExpanded();
      this.visible = this.isVisible();
      this.tree.updated(this);
    }
  }, {
    key: "updateChecked",
    value: function updateChecked() {
      var tree = this.tree,
        value = this.value;
      var checkedMap = tree.checkedMap;
      this.checked = this.isChecked();
      this.indeterminate = this.isIndeterminate();
      if (this.checked) {
        checkedMap.set(value, true);
      }
      tree.updated(this);
    }
  }, {
    key: "updateChildren",
    value: function updateChildren() {
      var children = this.children;
      if (Array.isArray(children)) {
        children.forEach(function (node) {
          node.update();
          node.updateChecked();
          node.updateChildren();
        });
      }
    }
  }, {
    key: "updateParents",
    value: function updateParents() {
      var parent = this.parent;
      if (parent) {
        parent.update();
        parent.updateChecked();
        parent.updateParents();
      }
    }
  }, {
    key: "updateRelated",
    value: function updateRelated() {
      var tree = this.tree;
      var relatedNodes = tree.getRelatedNodes([this.value]);
      relatedNodes.forEach(function (node) {
        node.update();
        node.updateChecked();
      });
    }
  }, {
    key: "walk",
    value: function walk() {
      var children = this.children;
      var list = [];
      list.push(this);
      if (Array.isArray(children) && children.length > 0) {
        children.forEach(function (node) {
          list = list.concat(node.walk());
        });
      }
      return list;
    }
  }, {
    key: "getModel",
    value: function getModel() {
      var model = this.model;
      if (!model) {
        model = createNodeModel(this);
        this.model = model;
      }
      updateNodeModel(model, this);
      return model;
    }
  }]);
}();

export { TreeNode, TreeNode as default, privateKey, setableProps, setableStatus, syncableProps };
//# sourceMappingURL=tree-node.js.map
