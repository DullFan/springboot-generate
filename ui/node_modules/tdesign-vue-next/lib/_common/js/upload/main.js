/**
 * tdesign v1.9.4
 * (c) 2024 tdesign
 * @license MIT
 */

import _toArray from '@babel/runtime/helpers/toArray';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import isFunction from 'lodash/isFunction';
import isNumber from 'lodash/isNumber';
import { isOverSizeLimit, getCurrentDate } from './utils.js';
import xhr from './xhr.js';
import log from '../log/log.js';
import '@babel/runtime/helpers/toConsumableArray';
import '@babel/runtime/helpers/typeof';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function handleBeforeUpload(file, params) {
  var sizeLimit = params.sizeLimit,
    beforeUpload = params.beforeUpload;
  var sizePromise = new Promise(function (resolve) {
    var result = null;
    if (sizeLimit) {
      var sizeLimitObj = isNumber(sizeLimit) ? {
        size: sizeLimit,
        unit: "KB"
      } : sizeLimit;
      var limit = isOverSizeLimit(file.size, sizeLimitObj.size, sizeLimitObj.unit);
      if (limit) {
        result = sizeLimitObj;
      }
    }
    resolve(result);
  });
  var promiseList = [sizePromise, void 0];
  if (isFunction(beforeUpload)) {
    var r = beforeUpload(file);
    var p = r instanceof Promise ? r : new Promise(function (resolve) {
      return resolve(r);
    });
    promiseList[1] = p;
  }
  return new Promise(function (resolve) {
    Promise.all(promiseList).then(function (r) {
      resolve(r);
    });
  });
}
function handleError(options) {
  var event = options.event,
    files = options.files,
    response = options.response,
    XMLHttpRequest = options.XMLHttpRequest,
    formatResponse = options.formatResponse;
  var res = response;
  if (isFunction(formatResponse)) {
    res = formatResponse(response, {
      file: files[0],
      currentFiles: files
    });
  }
  files.forEach(function (file) {
    file.status = "fail";
    file.response = res;
  });
  return {
    response: res,
    event: event,
    files: files,
    XMLHttpRequest: XMLHttpRequest
  };
}
function handleSuccess(params) {
  var event = params.event,
    files = params.files,
    response = params.response,
    XMLHttpRequest = params.XMLHttpRequest;
  if ((files === null || files === void 0 ? void 0 : files.length) <= 0) {
    log.error("Upload", "Empty File in Success Callback");
  }
  files.forEach(function (file) {
    var _file$response;
    file.percent = 100;
    file.status = "success";
    (_file$response = file.response) === null || _file$response === void 0 || delete _file$response.error;
  });
  var res = response;
  files[0].url = res.url || files[0].url;
  return {
    response: res,
    event: event,
    files: files,
    XMLHttpRequest: XMLHttpRequest
  };
}
function handleRequestMethodResponse(res) {
  if (!res) {
    log.error("Upload", "`requestMethodResponse` is required.");
    return false;
  }
  if (!res.status) {
    log.error("Upload", "`requestMethodResponse.status` is missing, which value only can be `success` or `fail`");
    return false;
  }
  if (!["success", "fail"].includes(res.status)) {
    log.error("Upload", "`requestMethodResponse.status` must be `success` or `fail`, examples `{ status: 'success', response: { url: '' } }`");
    return false;
  }
  if (res.status === "success" && (!res.response || !res.response.url && !res.response.files)) {
    log.warn("Upload", "`requestMethodResponse.response.url` or `requestMethodResponse.response.files` is required if `status` is `success`");
  }
  return true;
}
function uploadOneRequest(params) {
  var action = params.action,
    toUploadFiles = params.toUploadFiles,
    requestMethod = params.requestMethod;
  return new Promise(function (resolve) {
    if (!action && !requestMethod) {
      log.error("Upload", "one of action and requestMethod must be exist.");
      resolve({});
      return;
    }
    if (!toUploadFiles || !toUploadFiles.length) {
      log.warn("Upload", "No files need to be uploaded");
      resolve({});
      return;
    }
    toUploadFiles.forEach(function (file) {
      file.status = "progress";
    });
    if (requestMethod) {
      requestMethod(params.multiple ? toUploadFiles : toUploadFiles[0]).then(function (res) {
        if (!handleRequestMethodResponse(res)) {
          resolve({});
          return;
        }
        var response = res.response || {};
        if (isFunction(params.formatResponse)) {
          response = params.formatResponse(response, {
            file: toUploadFiles[0],
            currentFiles: toUploadFiles
          });
        }
        if (res.status === "fail") {
          response.error = res.error || response.error;
        }
        var resultFiles = [];
        if (res.status === "success" && response.files) {
          resultFiles = response.files.map(function (file) {
            var fileInfo = toUploadFiles.find(function (toFile) {
              return file.name && toFile.name === file.name || file.raw && toFile.raw === file.raw;
            });
            return _objectSpread(_objectSpread(_objectSpread({}, fileInfo), file), {}, {
              status: res.status,
              response: response
            });
          });
        } else {
          toUploadFiles.forEach(function (file) {
            var _response;
            file.status = res.status;
            file.response = response;
            file.url = response.url;
            file.percent = res.status === "success" ? 100 : 0;
            file.uploadTime = ((_response = response) === null || _response === void 0 ? void 0 : _response.uploadTime) || getCurrentDate();
          });
          resultFiles = toUploadFiles;
        }
        var result = {
          response: response,
          file: resultFiles[0],
          files: resultFiles
        };
        if (res.status === "success") {
          var _params$onResponseSuc;
          (_params$onResponseSuc = params.onResponseSuccess) === null || _params$onResponseSuc === void 0 || _params$onResponseSuc.call(params, result);
        } else if (res.status === "fail") {
          var _params$onResponseErr;
          (_params$onResponseErr = params.onResponseError) === null || _params$onResponseErr === void 0 || _params$onResponseErr.call(params, result);
        }
        resolve({
          status: res.status,
          data: result
        });
      });
    } else {
      var _params$setXhrObject;
      var xhrReq = xhr({
        action: params.action,
        files: params.toUploadFiles,
        useMockProgress: params.useMockProgress,
        mockProgressDuration: params.mockProgressDuration,
        onError: function onError(p) {
          var _params$onResponseErr2;
          var r = handleError(_objectSpread(_objectSpread({}, p), {}, {
            formatResponse: params.formatResponse
          }));
          (_params$onResponseErr2 = params.onResponseError) === null || _params$onResponseErr2 === void 0 || _params$onResponseErr2.call(params, r);
          resolve({
            status: "fail",
            data: r
          });
        },
        onProgress: params.onResponseProgress,
        onSuccess: function onSuccess(p) {
          var formatResponse = params.formatResponse;
          var res = p.response;
          if (isFunction(formatResponse)) {
            res = formatResponse(p.response, {
              file: p.file,
              currentFiles: p.files
            });
          }
          if (res.error) {
            var _params$onResponseErr3;
            var r = handleError(_objectSpread(_objectSpread({}, p), {}, {
              response: res
            }));
            (_params$onResponseErr3 = params.onResponseError) === null || _params$onResponseErr3 === void 0 || _params$onResponseErr3.call(params, r);
            resolve({
              status: "fail",
              data: r
            });
          } else {
            var _params$onResponseSuc2;
            p.file.response = res;
            p.files[0].response = res;
            var _r = handleSuccess(_objectSpread(_objectSpread({}, p), {}, {
              response: res
            }));
            (_params$onResponseSuc2 = params.onResponseSuccess) === null || _params$onResponseSuc2 === void 0 || _params$onResponseSuc2.call(params, _r);
            resolve({
              status: "success",
              data: _r
            });
          }
        },
        formatRequest: params.formatRequest,
        data: params.data,
        name: params.name,
        headers: params.headers,
        withCredentials: params.withCredentials,
        method: params.method
      });
      (_params$setXhrObject = params.setXhrObject) === null || _params$setXhrObject === void 0 || _params$setXhrObject.call(params, {
        files: params.toUploadFiles,
        xhrReq: xhrReq
      });
    }
  });
}
function updateUploadedFiles(uploadFiles, resultFiles) {
  var existFiles = uploadFiles.filter(function (t) {
    return t.url;
  });
  var newFiles = existFiles;
  var _loop = function _loop() {
    var file = resultFiles[i];
    var index = uploadFiles.findIndex(function (item) {
      return item.raw && item.raw === file.raw || item.name && item.name === file.name;
    });
    var tmpFile = index >= 0 ? _objectSpread(_objectSpread({}, uploadFiles[index]), file) : file;
    newFiles.push(tmpFile);
  };
  for (var i = 0, len = resultFiles.length; i < len; i++) {
    _loop();
  }
  return newFiles;
}
function upload(params) {
  var uploadAllFilesInOneRequest = params.uploadAllFilesInOneRequest,
    toUploadFiles = params.toUploadFiles,
    uploadedFiles = params.uploadedFiles,
    isBatchUpload = params.isBatchUpload;
  var thisUploadFiles = toUploadFiles.filter(function (t) {
    return !t.response || t.response && !t.response.error;
  });
  return new Promise(function (resolve) {
    if (uploadAllFilesInOneRequest || !params.multiple) {
      uploadOneRequest(params).then(function (r) {
        if (r.status === "success") {
          r.data.files = isBatchUpload || !params.multiple ? r.data.files : updateUploadedFiles(uploadedFiles, r.data.files);
        }
        var failedFiles = r.status === "fail" ? r.data.files : [];
        resolve(_objectSpread(_objectSpread({}, r), {}, {
          failedFiles: failedFiles
        }));
      });
      return;
    }
    var list = thisUploadFiles.map(function (file) {
      return uploadOneRequest(_objectSpread(_objectSpread({}, params), {}, {
        toUploadFiles: [file]
      }));
    });
    Promise.all(list).then(function (arr) {
      var files = [];
      var failedFiles = [];
      arr.forEach(function (one) {
        if (one.status === "success") {
          files.push(one.data.files[0]);
        } else if (one.status === "fail") {
          failedFiles.push(one.data.files[0]);
        }
      });
      var tFiles = params.autoUpload ? uploadedFiles.concat(files) : uploadedFiles;
      var newFiles = isBatchUpload || !params.multiple ? files : tFiles;
      resolve({
        status: files.length ? "success" : "fail",
        data: {
          files: newFiles
        },
        failedFiles: failedFiles,
        list: arr
      });
    });
  });
}
function formatToUploadFile(files, format) {
  var status = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;
  var percent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return files.map(function (fileRaw) {
    var file = fileRaw;
    if (isFunction(format)) {
      file = format(fileRaw);
    }
    var uploadFile = _objectSpread({
      raw: fileRaw,
      lastModified: fileRaw.lastModified,
      name: fileRaw.name,
      size: fileRaw.size,
      type: fileRaw.type,
      percent: percent,
      status: status
    }, file);
    return uploadFile;
  });
}
function validateFile(params) {
  var files = params.files,
    uploadValue = params.uploadValue,
    max = params.max,
    allowUploadDuplicateFile = params.allowUploadDuplicateFile;
  return new Promise(function (resolve) {
    var tmpFiles = files.filter(function (file) {
      var sameNameFile = uploadValue.find(function (t) {
        return t.name === file.name;
      });
      return allowUploadDuplicateFile || !sameNameFile;
    });
    var hasSameNameFile = false;
    if (tmpFiles.length < files.length) {
      hasSameNameFile = true;
    }
    if (!tmpFiles.length) {
      var tFiles = formatToUploadFile(files, params.format, params.autoUpload ? "progress" : "waiting");
      resolve({
        hasSameNameFile: hasSameNameFile,
        file: tFiles === null || tFiles === void 0 ? void 0 : tFiles[0],
        files: tFiles,
        validateResult: {
          type: "FILTER_FILE_SAME_NAME"
        }
      });
      return;
    }
    var lengthOverLimit = false;
    if (max && tmpFiles.length && !params.isBatchUpload) {
      var tmpFilesLenToBeAdded = tmpFiles.length;
      tmpFiles = tmpFiles.slice(0, max - uploadValue.length);
      if (tmpFilesLenToBeAdded + uploadValue.length > max) {
        lengthOverLimit = true;
      }
    }
    var formattedFiles = formatToUploadFile(tmpFiles, params.format, params.autoUpload ? "progress" : "waiting");
    var allFileValidatePromise;
    if (params.beforeAllFilesUpload) {
      var _params$beforeAllFile;
      var r = (_params$beforeAllFile = params.beforeAllFilesUpload) === null || _params$beforeAllFile === void 0 ? void 0 : _params$beforeAllFile.call(params, formattedFiles);
      allFileValidatePromise = r instanceof Promise ? r : new Promise(function (resolve2) {
        return resolve2(r);
      });
    }
    var promiseList = formattedFiles.map(function (file) {
      return new Promise(function (resolve2) {
        handleBeforeUpload(file, {
          beforeUpload: params.beforeUpload,
          sizeLimit: params.sizeLimit
        }).then(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            sizeResult = _ref2[0],
            customResult = _ref2[1];
          if (sizeResult) {
            resolve2({
              file: file,
              validateResult: {
                type: "FILE_OVER_SIZE_LIMIT",
                extra: sizeResult
              }
            });
          } else if (customResult === false) {
            resolve2({
              file: file,
              validateResult: {
                type: "CUSTOM_BEFORE_UPLOAD"
              }
            });
          }
          resolve2({
            file: file
          });
        });
      });
    });
    Promise.all([allFileValidatePromise].concat(promiseList)).then(function (results) {
      var _results = _toArray(results),
        allFilesResult = _results[0],
        others = _results.slice(1);
      if (allFilesResult === false) {
        resolve({
          lengthOverLimit: lengthOverLimit,
          hasSameNameFile: hasSameNameFile,
          validateResult: {
            type: "BEFORE_ALL_FILES_UPLOAD"
          },
          files: formattedFiles
        });
      } else {
        resolve({
          lengthOverLimit: lengthOverLimit,
          hasSameNameFile: hasSameNameFile,
          fileValidateList: others,
          files: formattedFiles
        });
      }
    });
  });
}
function getFilesAndErrors(fileValidateList, getError) {
  var sizeLimitErrors = [];
  var beforeUploadErrorFiles = [];
  var toFiles = [];
  fileValidateList.forEach(function (oneFile) {
    var _oneFile$validateResu, _oneFile$validateResu2;
    if (((_oneFile$validateResu = oneFile.validateResult) === null || _oneFile$validateResu === void 0 ? void 0 : _oneFile$validateResu.type) === "CUSTOM_BEFORE_UPLOAD") {
      beforeUploadErrorFiles.push(oneFile.file);
      return;
    }
    if (((_oneFile$validateResu2 = oneFile.validateResult) === null || _oneFile$validateResu2 === void 0 ? void 0 : _oneFile$validateResu2.type) === "FILE_OVER_SIZE_LIMIT") {
      if (!oneFile.file.response) {
        oneFile.file.response = {};
      }
      oneFile.file.response.error = oneFile.file.response.error || getError(oneFile.validateResult.extra);
      sizeLimitErrors.push(oneFile);
      return;
    }
    toFiles.push(oneFile.file);
  });
  return {
    sizeLimitErrors: sizeLimitErrors,
    beforeUploadErrorFiles: beforeUploadErrorFiles,
    toFiles: toFiles
  };
}
function getTriggerTextField(p) {
  if (p.isBatchUpload && p.status) return "reupload";
  if (p.status === "fail") return "reupload";
  if (p.status === "progress") return "uploading";
  if (p.status === "success" || !p.autoUpload && p.status === "waiting") {
    return p.multiple ? "continueUpload" : "reupload";
  }
  return "fileInput";
}
function getDisplayFiles(params) {
  var multiple = params.multiple,
    uploadValue = params.uploadValue,
    toUploadFiles = params.toUploadFiles,
    autoUpload = params.autoUpload;
  var waitingUploadFiles = autoUpload ? toUploadFiles : toUploadFiles.filter(function (file) {
    return file.status !== "success";
  });
  if (multiple && !params.isBatchUpload) {
    if (!autoUpload) return uploadValue;
    return (waitingUploadFiles.length ? uploadValue.concat(waitingUploadFiles) : uploadValue) || [];
  }
  return (waitingUploadFiles.length ? waitingUploadFiles : uploadValue) || [];
}

export { formatToUploadFile, getDisplayFiles, getFilesAndErrors, getTriggerTextField, handleBeforeUpload, handleError, handleRequestMethodResponse, handleSuccess, upload, uploadOneRequest, validateFile };
//# sourceMappingURL=main.js.map
