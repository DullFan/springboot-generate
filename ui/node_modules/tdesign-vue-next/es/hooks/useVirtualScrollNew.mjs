/**
 * tdesign v1.9.4
 * (c) 2024 tdesign
 * @license MIT
 */

import { _ as _toConsumableArray } from '../_chunks/dep-83cdf63a.mjs';
import { _ as _slicedToArray } from '../_chunks/dep-f29ee43a.mjs';
import { ref, computed, watch } from 'vue';
import useResizeObserver from './useResizeObserver.mjs';
import '../_chunks/dep-ad0f5c12.mjs';
import { i as isSymbol_1 } from '../_chunks/dep-8e0cf610.mjs';
import { i as identity_1 } from '../_chunks/dep-551a93fd.mjs';
import { t as throttle_1 } from '../_chunks/dep-eb82bf9c.mjs';
import '../_chunks/dep-04fa0fa7.mjs';
import '../_chunks/dep-8a6a0750.mjs';
import '../_chunks/dep-de0d9668.mjs';
import '../_chunks/dep-c23362d5.mjs';
import '../_chunks/dep-6cd78bb0.mjs';
import '../_chunks/dep-a053ff3d.mjs';
import '../_chunks/dep-65c48aa3.mjs';
import '../_chunks/dep-786a7628.mjs';

var isSymbol = isSymbol_1;

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum$2(array, iteratee, comparator) {
  var index = -1,
    length = array.length;
  while (++index < length) {
    var value = array[index],
      current = iteratee(value);
    if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
      var computed = current,
        result = value;
    }
  }
  return result;
}
var _baseExtremum = baseExtremum$2;

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt$1(value, other) {
  return value > other;
}
var _baseGt = baseGt$1;

var baseExtremum$1 = _baseExtremum,
  baseGt = _baseGt,
  identity$2 = identity_1;

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return array && array.length ? baseExtremum$1(array, identity$2, baseGt) : undefined;
}
var max_1 = max;

/**
 * The base implementation of `_.lt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */
function baseLt$1(value, other) {
  return value < other;
}
var _baseLt = baseLt$1;

var baseExtremum = _baseExtremum,
  baseLt = _baseLt,
  identity$1 = identity_1;

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * _.min([4, 2, 8, 6]);
 * // => 2
 *
 * _.min([]);
 * // => undefined
 */
function min(array) {
  return array && array.length ? baseExtremum(array, identity$1, baseLt) : undefined;
}
var min_1 = min;

/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum$1(array, iteratee) {
  var result,
    index = -1,
    length = array.length;
  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : result + current;
    }
  }
  return result;
}
var _baseSum = baseSum$1;

var baseSum = _baseSum,
  identity = identity_1;

/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */
function sum(array) {
  return array && array.length ? baseSum(array, identity) : 0;
}
var sum_1 = sum;

var useVirtualScroll = function useVirtualScroll(container, params) {
  var _params$value$data, _params$value$scroll;
  var visibleData = ref([]);
  var translateY = ref((((_params$value$data = params.value.data) === null || _params$value$data === void 0 ? void 0 : _params$value$data.length) || 0) * (((_params$value$scroll = params.value.scroll) === null || _params$value$scroll === void 0 ? void 0 : _params$value$scroll.rowHeight) || 50));
  var scrollHeight = ref(0);
  var trHeightList = [];
  var containerHeight = ref(0);
  var containerWidth = ref(0);
  var startAndEndIndex = ref([0, 15]);
  var tScroll = computed(function () {
    var _scroll$isFixedRowHei;
    var scroll = params.value.scroll;
    if (!scroll) return {};
    return {
      bufferSize: scroll.bufferSize || 10,
      isFixedRowHeight: (_scroll$isFixedRowHei = scroll.isFixedRowHeight) !== null && _scroll$isFixedRowHei !== void 0 ? _scroll$isFixedRowHei : false,
      rowHeight: scroll.rowHeight || 47,
      threshold: scroll.threshold || 100,
      type: scroll.type
    };
  });
  var isVirtualScroll = computed(function () {
    var data = params.value.data;
    return tScroll.value.type === "virtual" && tScroll.value.threshold < data.length;
  });
  function getVisibleRangeConfig() {
    var _container$value$scro, _container$value;
    var scrollTop = (_container$value$scro = (_container$value = container.value) === null || _container$value === void 0 ? void 0 : _container$value.scrollTop) !== null && _container$value$scro !== void 0 ? _container$value$scro : 0;
    var prevBufferHeightList = [];
    var hiddenHeight = 0;
    var visibleStart = -1;
    var visibleEnd = -1;
    var totalHeight = 0;
    for (var i = 0, len = params.value.data.length; i < len; i++) {
      var _trHeightList$i;
      var rowHeight = (_trHeightList$i = trHeightList[i]) !== null && _trHeightList$i !== void 0 ? _trHeightList$i : tScroll.value.rowHeight;
      totalHeight = totalHeight + rowHeight;
      if (totalHeight > scrollTop && visibleStart === -1) {
        visibleStart = i;
        if (visibleStart - tScroll.value.bufferSize > 0) {
          hiddenHeight = totalHeight - rowHeight - sum_1(prevBufferHeightList);
        }
      }
      if (visibleStart === -1) {
        prevBufferHeightList.push(rowHeight);
        if (prevBufferHeightList.length > tScroll.value.bufferSize) {
          prevBufferHeightList.shift();
        }
      }
      if (visibleEnd === -1 && (totalHeight > containerHeight.value + scrollTop || i === params.value.data.length - 1)) {
        visibleEnd = i;
      }
      if (visibleStart !== -1 && visibleEnd !== -1) {
        break;
      }
    }
    var startIndex = max_1([visibleStart - tScroll.value.bufferSize, 0]);
    var endIndex = min_1([visibleEnd + tScroll.value.bufferSize, params.value.data.length]);
    return {
      startIndex: startIndex,
      endIndex: endIndex,
      translateY: hiddenHeight
    };
  }
  var updateVisibleData = throttle_1(function () {
    var _getVisibleRangeConfi = getVisibleRangeConfig(),
      startIndex = _getVisibleRangeConfi.startIndex,
      endIndex = _getVisibleRangeConfi.endIndex,
      translateYValue = _getVisibleRangeConfi.translateY;
    if (startAndEndIndex.value.join() !== [startIndex, endIndex].join() && startIndex >= 0) {
      translateY.value = translateYValue;
      visibleData.value = params.value.data.slice(startIndex, endIndex);
      startAndEndIndex.value = [startIndex, endIndex];
    }
  }, 100);
  var handleRowMounted = function handleRowMounted(rowData) {
    var _rowData$ref$value;
    if (!isVirtualScroll.value || !rowData || tScroll.value.isFixedRowHeight || !container.value) return;
    var trHeight = (_rowData$ref$value = rowData.ref.value) === null || _rowData$ref$value === void 0 ? void 0 : _rowData$ref$value.getBoundingClientRect().height;
    var rowIndex = rowData.data.VIRTUAL_SCROLL_INDEX;
    if (trHeightList[rowIndex] !== trHeight) {
      var diff = trHeight - trHeightList[rowIndex];
      trHeightList[rowIndex] = trHeight;
      scrollHeight.value = scrollHeight.value + diff;
    }
  };
  var handleScroll = function handleScroll() {
    if (!isVirtualScroll.value) return;
    updateVisibleData();
  };
  var refreshVirtualScroll = function refreshVirtualScroll(_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
      contentRect = _ref2[0].contentRect;
    var maxScrollbarWidth = 16;
    if (Math.abs(contentRect.width - containerWidth.value) > maxScrollbarWidth) {
      container.value.scrollTop = 0;
      translateY.value = 0;
    }
    containerWidth.value = contentRect.width;
    containerHeight.value = contentRect.height;
  };
  var addIndexToData = function addIndexToData(data) {
    data.forEach(function (item, index) {
      item["VIRTUAL_SCROLL_INDEX"] = index;
    });
  };
  var updateScrollTop = function updateScrollTop(_ref3) {
    var index = _ref3.index,
      _ref3$top = _ref3.top,
      top = _ref3$top === void 0 ? 0 : _ref3$top,
      behavior = _ref3.behavior;
    var scrollTop = sum_1(trHeightList.slice(0, index)) - top;
    container.value.scrollTo({
      top: scrollTop,
      behavior: behavior || "auto"
    });
  };
  var scrollToElement = function scrollToElement(p) {
    updateScrollTop(p);
    if (!tScroll.value.isFixedRowHeight) {
      var _p$time;
      var duration = (_p$time = p.time) !== null && _p$time !== void 0 ? _p$time : 60;
      var timer = setTimeout(function () {
        updateScrollTop(p);
        clearTimeout(timer);
      }, duration);
    }
  };
  useResizeObserver(computed(function () {
    return isVirtualScroll.value ? container.value : void 0;
  }), refreshVirtualScroll);
  watch(function () {
    return [_toConsumableArray(params.value.data), tScroll.value, isVirtualScroll.value, container.value];
  }, function () {
    if (!isVirtualScroll.value || !container.value) return;
    var data = params.value.data;
    addIndexToData(data);
    containerHeight.value = container.value.getBoundingClientRect().height;
    if (trHeightList.length !== params.value.data.length) {
      var initHeightList = Array.from(trHeightList);
      initHeightList.length = params.value.data.length;
      initHeightList.fill(tScroll.value.rowHeight || 47);
      trHeightList = initHeightList;
    }
    scrollHeight.value = sum_1(trHeightList);
    startAndEndIndex.value = [0, 0];
    updateVisibleData();
  }, {
    immediate: true
  });
  watch(function () {
    return containerHeight.value;
  }, function () {
    updateVisibleData();
  });
  return {
    visibleData: visibleData,
    translateY: translateY,
    scrollHeight: scrollHeight,
    isVirtualScroll: isVirtualScroll,
    handleScroll: handleScroll,
    handleRowMounted: handleRowMounted,
    scrollToElement: scrollToElement
  };
};

export { useVirtualScroll as default };
//# sourceMappingURL=useVirtualScrollNew.mjs.map
