/**
 * tdesign v1.9.4
 * (c) 2024 tdesign
 * @license MIT
 */

import { _ as _slicedToArray } from '../../_chunks/dep-f29ee43a.mjs';
import { _ as _defineProperty } from '../../_chunks/dep-2dead3b8.mjs';
import { toRefs, ref, reactive, computed, watch, onMounted, onBeforeUnmount } from 'vue';
import { g as get_1 } from '../../_chunks/dep-87670918.mjs';
import { d as debounce_1 } from '../../_chunks/dep-6cd78bb0.mjs';
import '../../_chunks/dep-ad0f5c12.mjs';
import { _ as _arrayFilter } from '../../_chunks/dep-45a70a53.mjs';
import { _ as _baseRest, i as isArrayLikeObject_1 } from '../../_chunks/dep-5b74d046.mjs';
import { _ as _baseDifference } from '../../_chunks/dep-9cc70af8.mjs';
import { a as _baseFlatten } from '../../_chunks/dep-a1a5cc96.mjs';
import { _ as _SetCache, a as _cacheHas } from '../../_chunks/dep-1cfe79e3.mjs';
import { _ as _arrayIncludes, a as _arrayIncludesWith } from '../../_chunks/dep-f5c953e5.mjs';
import { _ as _Set } from '../../_chunks/dep-5c0cf5f9.mjs';
import { _ as _setToArray } from '../../_chunks/dep-2a455a8f.mjs';
import { l as last_1 } from '../../_chunks/dep-c0c2d9c7.mjs';
import '../../_common/js/log/index.mjs';
import { getScrollbarWidthWithCSS } from '../../_common/js/utils/getScrollbarWidth.mjs';
import { off, on } from '../../utils/dom.mjs';
import { getIEVersion } from '../../_common/js/utils/helper.mjs';
import { p as pick_1 } from '../../_chunks/dep-85cd63c4.mjs';
import log from '../../_common/js/log/log.mjs';
import '../../_chunks/dep-04fa0fa7.mjs';
import '../../_chunks/dep-8a6a0750.mjs';
import '../../_chunks/dep-ee7aa1c5.mjs';
import '../../_chunks/dep-4ef63f67.mjs';
import '../../_chunks/dep-f5bde8c1.mjs';
import '../../_chunks/dep-8e0cf610.mjs';
import '../../_chunks/dep-de0d9668.mjs';
import '../../_chunks/dep-c23362d5.mjs';
import '../../_chunks/dep-203afd59.mjs';
import '../../_chunks/dep-48235a7f.mjs';
import '../../_chunks/dep-706c37a3.mjs';
import '../../_chunks/dep-a053ff3d.mjs';
import '../../_chunks/dep-65c48aa3.mjs';
import '../../_chunks/dep-82bdd07b.mjs';
import '../../_chunks/dep-bfe0dcb6.mjs';
import '../../_chunks/dep-056e3d49.mjs';
import '../../_chunks/dep-786a7628.mjs';
import '../../_chunks/dep-0126dffd.mjs';
import '../../_chunks/dep-551a93fd.mjs';
import '../../_chunks/dep-672a56f9.mjs';
import '../../_chunks/dep-b15f1e4a.mjs';
import '../../_chunks/dep-64862a5a.mjs';
import '../../_chunks/dep-c6ed1157.mjs';
import '../../_chunks/dep-d5cc8b5d.mjs';
import '../../utils/easing.mjs';
import '../../_chunks/dep-83cdf63a.mjs';
import '../../_chunks/dep-28f56d24.mjs';
import '../../_chunks/dep-660119a6.mjs';
import '../../_chunks/dep-fb07e55c.mjs';
import '../../_chunks/dep-844e471b.mjs';
import '../../_chunks/dep-f6f516d9.mjs';
import '../../_chunks/dep-e8c6972d.mjs';
import '../../_chunks/dep-9b1e7043.mjs';
import '../../_chunks/dep-6f363254.mjs';

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop$1() {
  // No operation performed.
}
var noop_1 = noop$1;

var Set = _Set,
  noop = noop_1,
  setToArray$1 = _setToArray;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet$1 = !(Set && 1 / setToArray$1(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
  return new Set(values);
};
var _createSet = createSet$1;

var SetCache = _SetCache,
  arrayIncludes = _arrayIncludes,
  arrayIncludesWith = _arrayIncludesWith,
  cacheHas = _cacheHas,
  createSet = _createSet,
  setToArray = _setToArray;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq$1(array, iteratee, comparator) {
  var index = -1,
    includes = arrayIncludes,
    length = array.length,
    isCommon = true,
    result = [],
    seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer: while (++index < length) {
    var value = array[index],
      computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}
var _baseUniq = baseUniq$1;

var baseDifference = _baseDifference,
  baseFlatten = _baseFlatten,
  baseUniq = _baseUniq;

/**
 * The base implementation of methods like `_.xor`, without support for
 * iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of values.
 */
function baseXor$1(arrays, iteratee, comparator) {
  var length = arrays.length;
  if (length < 2) {
    return length ? baseUniq(arrays[0]) : [];
  }
  var index = -1,
    result = Array(length);
  while (++index < length) {
    var array = arrays[index],
      othIndex = -1;
    while (++othIndex < length) {
      if (othIndex != index) {
        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
      }
    }
  }
  return baseUniq(baseFlatten(result, 1), iteratee, comparator);
}
var _baseXor = baseXor$1;

var arrayFilter = _arrayFilter,
  baseRest = _baseRest,
  baseXor = _baseXor,
  isArrayLikeObject = isArrayLikeObject_1,
  last = last_1;

/**
 * This method is like `_.xor` except that it accepts `comparator` which is
 * invoked to compare elements of `arrays`. The order of result values is
 * determined by the order they occur in the arrays. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.xorWith(objects, others, _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
var xorWith = baseRest(function (arrays) {
  var comparator = last(arrays);
  comparator = typeof comparator == 'function' ? comparator : undefined;
  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
});
var xorWith_1 = xorWith;

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function getColumnFixedStyles(col, index, rowAndColFixedPosition, tableColFixedClasses) {
  var fixedPos = rowAndColFixedPosition === null || rowAndColFixedPosition === void 0 ? void 0 : rowAndColFixedPosition.get(col.colKey || index);
  if (!fixedPos) return {};
  var thClasses = _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, tableColFixedClasses.left, col.fixed === "left"), tableColFixedClasses.right, col.fixed === "right"), tableColFixedClasses.lastLeft, col.fixed === "left" && fixedPos.lastLeftFixedCol), tableColFixedClasses.firstRight, col.fixed === "right" && fixedPos.firstRightFixedCol);
  var thStyles = {
    left: col.fixed === "left" ? "".concat(fixedPos.left, "px") : void 0,
    right: col.fixed === "right" ? "".concat(fixedPos.right, "px") : void 0
  };
  return {
    style: thStyles,
    classes: thClasses
  };
}
function getRowFixedStyles(rowId, rowIndex, rowLength, fixedRows, rowAndColFixedPosition, tableRowFixedClasses) {
  if (!fixedRows || !fixedRows.length) return {
    style: void 0,
    classes: void 0
  };
  var fixedTop = rowIndex < fixedRows[0];
  var fixedBottom = rowIndex > rowLength - 1 - fixedRows[1];
  var firstFixedBottomRow = rowLength - fixedRows[1];
  var fixedPos = (rowAndColFixedPosition === null || rowAndColFixedPosition === void 0 ? void 0 : rowAndColFixedPosition.get(rowId)) || {};
  var rowClasses = _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, tableRowFixedClasses.top, fixedTop), tableRowFixedClasses.bottom, fixedBottom), tableRowFixedClasses.firstBottom, rowIndex === firstFixedBottomRow), tableRowFixedClasses.withoutBorderBottom, rowIndex === firstFixedBottomRow - 1);
  var rowStyles = {
    top: fixedTop ? "".concat(fixedPos.top, "px") : void 0,
    bottom: fixedBottom ? "".concat(fixedPos.bottom, "px") : void 0
  };
  return {
    style: rowStyles,
    classes: rowClasses
  };
}
function useFixed(props, context, finalColumns, affixRef) {
  var _toRefs = toRefs(props),
    columns = _toRefs.columns,
    tableLayout = _toRefs.tableLayout,
    tableContentWidth = _toRefs.tableContentWidth,
    fixedRows = _toRefs.fixedRows,
    firstFullRow = _toRefs.firstFullRow,
    lastFullRow = _toRefs.lastFullRow,
    maxHeight = _toRefs.maxHeight,
    headerAffixedTop = _toRefs.headerAffixedTop,
    footerAffixedBottom = _toRefs.footerAffixedBottom,
    bordered = _toRefs.bordered,
    resizable = _toRefs.resizable,
    allowResizeColumnWidth = _toRefs.allowResizeColumnWidth;
  var data = ref([]);
  var tableRef = ref();
  var tableContentRef = ref();
  var isFixedHeader = ref(false);
  var isWidthOverflow = ref(false);
  var tableElmRef = ref();
  var scrollbarWidth = ref(6);
  var rowAndColFixedPosition = ref( /* @__PURE__ */new Map());
  var showColumnShadow = reactive({
    left: false,
    right: false
  });
  var virtualScrollHeaderPos = ref({
    left: 0,
    top: 0
  });
  var tableWidth = ref(0);
  var tableElmWidth = ref(0);
  var thWidthList = ref({});
  var isFixedColumn = ref(false);
  var isFixedRightColumn = ref(false);
  var isFixedLeftColumn = ref(false);
  var columnResizable = computed(function () {
    var _ref, _allowResizeColumnWid;
    return (_ref = (_allowResizeColumnWid = allowResizeColumnWidth.value) !== null && _allowResizeColumnWid !== void 0 ? _allowResizeColumnWid : resizable.value) !== null && _ref !== void 0 ? _ref : false;
  });
  var notNeedThWidthList = computed(function () {
    var _props$scroll;
    return !(props.headerAffixedTop || props.footerAffixedBottom || props.horizontalScrollAffixedBottom || ((_props$scroll = props.scroll) === null || _props$scroll === void 0 ? void 0 : _props$scroll.type) === "virtual");
  });
  function setUseFixedTableElmRef(val) {
    tableElmRef.value = val;
  }
  function getColumnMap(columns2) {
    var map = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /* @__PURE__ */new Map();
    var levelNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var parent = arguments.length > 4 ? arguments[4] : undefined;
    for (var i = 0, len = columns2.length; i < len; i++) {
      var _col$children;
      var col = columns2[i];
      if (["left", "right"].includes(col.fixed)) {
        isFixedColumn.value = true;
      }
      if (col.fixed === "right") {
        isFixedRightColumn.value = true;
      }
      if (col.fixed === "left") {
        isFixedLeftColumn.value = true;
      }
      var key = col.colKey || i;
      var columnInfo = {
        col: col,
        parent: parent,
        index: i
      };
      map.set(key, columnInfo);
      if ((_col$children = col.children) !== null && _col$children !== void 0 && _col$children.length) {
        getColumnMap(col.children, map, levelNodes, level + 1, columnInfo);
      }
      if (levelNodes[level]) {
        levelNodes[level].push(columnInfo);
      } else {
        levelNodes[level] = [columnInfo];
      }
    }
    return {
      newColumnsMap: map,
      levelNodes: levelNodes
    };
  }
  var setFixedLeftPos = function setFixedLeftPos(columns2, initialColumnMap) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    for (var i = 0, len = columns2.length; i < len; i++) {
      var _col$children2;
      var col = columns2[i];
      if (col.fixed === "right") return;
      var colInfo = initialColumnMap.get(col.colKey || i);
      var lastColIndex = i - 1;
      while (lastColIndex >= 0 && columns2[lastColIndex].fixed !== "left") {
        lastColIndex -= 1;
      }
      var lastCol = columns2[lastColIndex];
      var defaultWidth = i === 0 ? (parent === null || parent === void 0 ? void 0 : parent.left) || 0 : 0;
      var lastColInfo = initialColumnMap.get((lastCol === null || lastCol === void 0 ? void 0 : lastCol.colKey) || i - 1);
      if (colInfo) {
        colInfo.left = ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.left) || defaultWidth) + ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.width) || 0);
      }
      if ((_col$children2 = col.children) !== null && _col$children2 !== void 0 && _col$children2.length) {
        setFixedLeftPos(col.children, initialColumnMap, colInfo);
      }
    }
  };
  var setFixedRightPos = function setFixedRightPos(columns2, initialColumnMap) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    for (var i = columns2.length - 1; i >= 0; i--) {
      var _col$children3;
      var col = columns2[i];
      if (col.fixed === "left") return;
      var colInfo = initialColumnMap.get(col.colKey || i);
      var lastColIndex = i + 1;
      while (lastColIndex < columns2.length && columns2[lastColIndex].fixed !== "right") {
        lastColIndex += 1;
      }
      var lastCol = columns2[lastColIndex];
      var defaultWidth = i === columns2.length - 1 ? (parent === null || parent === void 0 ? void 0 : parent.right) || 0 : 0;
      var lastColInfo = initialColumnMap.get((lastCol === null || lastCol === void 0 ? void 0 : lastCol.colKey) || i + 1);
      if (colInfo) {
        colInfo.right = ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.right) || defaultWidth) + ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.width) || 0);
      }
      if ((_col$children3 = col.children) !== null && _col$children3 !== void 0 && _col$children3.length) {
        setFixedRightPos(col.children, initialColumnMap, colInfo);
      }
    }
  };
  var setFixedColPosition = function setFixedColPosition(trList, initialColumnMap) {
    if (!trList) return;
    for (var i = 0, len = trList.length; i < len; i++) {
      var thList = trList[i].children;
      for (var j = 0, thLen = thList.length; j < thLen; j++) {
        var _obj$col;
        var th = thList[j];
        var colKey = th.dataset.colkey;
        if (!colKey) {
          log.warn("TDesign Table", "".concat(th.innerText, " missing colKey. colKey is required for fixed column feature."));
        }
        var obj = initialColumnMap.get(colKey || j);
        if (obj !== null && obj !== void 0 && (_obj$col = obj.col) !== null && _obj$col !== void 0 && _obj$col.fixed) {
          initialColumnMap.set(colKey, _objectSpread(_objectSpread({}, obj), {}, {
            width: th.getBoundingClientRect().width
          }));
        }
      }
    }
    setFixedLeftPos(columns.value, initialColumnMap);
    setFixedRightPos(columns.value, initialColumnMap);
  };
  var setFixedRowPosition = function setFixedRowPosition(trList, initialColumnMap, thead, tfoot) {
    var _ref2 = fixedRows.value || [],
      _ref3 = _slicedToArray(_ref2, 2),
      fixedTopRows = _ref3[0],
      fixedBottomRows = _ref3[1];
    var data2 = props.data,
      _props$rowKey = props.rowKey,
      rowKey = _props$rowKey === void 0 ? "id" : _props$rowKey;
    for (var i = 0; i < fixedTopRows; i++) {
      var tr = trList[i];
      var rowId = get_1(data2[i], rowKey);
      var thisRowInfo = initialColumnMap.get(rowId) || {};
      var lastRowId = get_1(data2[i - 1], rowKey);
      var lastRowInfo = initialColumnMap.get(lastRowId) || {};
      var defaultBottom = 0;
      if (i === 0) {
        defaultBottom = (thead === null || thead === void 0 ? void 0 : thead.getBoundingClientRect().height) || 0;
      }
      thisRowInfo.top = (lastRowInfo.top || defaultBottom) + (lastRowInfo.height || 0);
      initialColumnMap.set(rowId, _objectSpread(_objectSpread({}, thisRowInfo), {}, {
        height: (tr === null || tr === void 0 ? void 0 : tr.getBoundingClientRect().height) || 0
      }));
    }
    for (var _i = data2.length - 1; _i >= data2.length - fixedBottomRows; _i--) {
      var _tr = trList[_i];
      var _rowId = get_1(data2[_i], rowKey);
      var _thisRowInfo = initialColumnMap.get(_rowId) || {};
      var _lastRowId = get_1(data2[_i + 1], rowKey);
      var _lastRowInfo = initialColumnMap.get(_lastRowId) || {};
      var _defaultBottom = 0;
      if (_i === data2.length - 1) {
        _defaultBottom = (tfoot === null || tfoot === void 0 ? void 0 : tfoot.getBoundingClientRect().height) || 0;
      }
      _thisRowInfo.bottom = (_lastRowInfo.bottom || _defaultBottom) + (_lastRowInfo.height || 0);
      initialColumnMap.set(_rowId, _objectSpread(_objectSpread({}, _thisRowInfo), {}, {
        height: (_tr === null || _tr === void 0 ? void 0 : _tr.getBoundingClientRect().height) || 0
      }));
    }
  };
  var updateRowAndColFixedPosition = function updateRowAndColFixedPosition(tableContentElm, initialColumnMap) {
    rowAndColFixedPosition.value.clear();
    if (!tableContentElm) return;
    var thead = tableContentElm.querySelector("thead");
    thead && setFixedColPosition(thead.children, initialColumnMap);
    var tbody = tableContentElm.querySelector("tbody");
    var tfoot = tableContentElm.querySelector("tfoot");
    tbody && setFixedRowPosition(tbody.children, initialColumnMap, thead, tfoot);
    rowAndColFixedPosition.value = initialColumnMap;
  };
  var shadowLastScrollLeft;
  var updateColumnFixedShadow = function updateColumnFixedShadow(target, extra) {
    if (!isFixedColumn.value || !target) return;
    var scrollLeft = target.scrollLeft;
    if (shadowLastScrollLeft === scrollLeft && (!extra || !extra.skipScrollLimit)) return;
    shadowLastScrollLeft = scrollLeft;
    var isShowRight = target.clientWidth + scrollLeft < target.scrollWidth;
    var isShowLeft = scrollLeft > 0;
    if (showColumnShadow.left === isShowLeft && showColumnShadow.right === isShowRight) return;
    showColumnShadow.left = isShowLeft && isFixedLeftColumn.value;
    showColumnShadow.right = isShowRight && isFixedRightColumn.value;
  };
  var setIsLastOrFirstFixedCol = function setIsLastOrFirstFixedCol(levelNodes) {
    for (var t = 0; t < levelNodes.length; t++) {
      var nodes = levelNodes[t];
      for (var i = 0, len = nodes.length; i < len; i++) {
        var colMapInfo = nodes[i];
        var nextColMapInfo = nodes[i + 1];
        var parent = colMapInfo.parent;
        var isParentLastLeftFixedCol = !parent || (parent === null || parent === void 0 ? void 0 : parent.lastLeftFixedCol);
        if (isParentLastLeftFixedCol && colMapInfo.col.fixed === "left" && (nextColMapInfo === null || nextColMapInfo === void 0 ? void 0 : nextColMapInfo.col.fixed) !== "left") {
          colMapInfo.lastLeftFixedCol = true;
        }
        var lastColMapInfo = nodes[i - 1];
        var isParentFirstRightFixedCol = !parent || (parent === null || parent === void 0 ? void 0 : parent.firstRightFixedCol);
        if (isParentFirstRightFixedCol && colMapInfo.col.fixed === "right" && (lastColMapInfo === null || lastColMapInfo === void 0 ? void 0 : lastColMapInfo.col.fixed) !== "right") {
          colMapInfo.firstRightFixedCol = true;
        }
      }
    }
  };
  var updateFixedStatus = function updateFixedStatus() {
    var _getColumnMap = getColumnMap(columns.value),
      newColumnsMap = _getColumnMap.newColumnsMap,
      levelNodes = _getColumnMap.levelNodes;
    setIsLastOrFirstFixedCol(levelNodes);
    var timer = setTimeout(function () {
      var _fixedRows$value;
      if (isFixedColumn.value || (_fixedRows$value = fixedRows.value) !== null && _fixedRows$value !== void 0 && _fixedRows$value.length) {
        updateRowAndColFixedPosition(tableContentRef.value, newColumnsMap);
      }
      clearTimeout(timer);
    }, 0);
    return function () {
      clearTimeout(timer);
    };
  };
  var updateFixedHeader = function updateFixedHeader() {
    var timer = setTimeout(function () {
      if (!tableContentRef.value) return;
      isFixedHeader.value = tableContentRef.value.scrollHeight > tableContentRef.value.clientHeight;
      isWidthOverflow.value = tableContentRef.value.scrollWidth > tableContentRef.value.clientWidth;
      var pos = tableContentRef.value.getBoundingClientRect();
      virtualScrollHeaderPos.value = {
        top: pos.top,
        left: pos.left
      };
      clearTimeout(timer);
    }, 0);
  };
  var setTableElmWidth = function setTableElmWidth(width) {
    if (tableElmWidth.value === width) return;
    tableElmWidth.value = width;
  };
  var updateTableWidth = function updateTableWidth() {
    var _tableContentRef$valu, _tableElmRef$value;
    var rect = (_tableContentRef$valu = tableContentRef.value) === null || _tableContentRef$valu === void 0 ? void 0 : _tableContentRef$valu.getBoundingClientRect();
    if (!rect) return;
    var reduceWidth = isFixedHeader.value ? scrollbarWidth.value : 0;
    tableWidth.value = rect.width - reduceWidth - (props.bordered ? 1 : 0);
    var elmRect = tableElmRef === null || tableElmRef === void 0 || (_tableElmRef$value = tableElmRef.value) === null || _tableElmRef$value === void 0 ? void 0 : _tableElmRef$value.getBoundingClientRect();
    (elmRect === null || elmRect === void 0 ? void 0 : elmRect.width) && setTableElmWidth(elmRect.width);
  };
  var updateAffixPosition = function updateAffixPosition() {
    var _affixRef$paginationA, _affixRef$paginationA2, _affixRef$horizontalS, _affixRef$horizontalS2, _affixRef$headerTopAf, _affixRef$headerTopAf2, _affixRef$footerBotto, _affixRef$footerBotto2;
    (_affixRef$paginationA = affixRef.paginationAffixRef.value) === null || _affixRef$paginationA === void 0 || (_affixRef$paginationA2 = _affixRef$paginationA.handleScroll) === null || _affixRef$paginationA2 === void 0 || _affixRef$paginationA2.call(_affixRef$paginationA);
    (_affixRef$horizontalS = affixRef.horizontalScrollAffixRef.value) === null || _affixRef$horizontalS === void 0 || (_affixRef$horizontalS2 = _affixRef$horizontalS.handleScroll) === null || _affixRef$horizontalS2 === void 0 || _affixRef$horizontalS2.call(_affixRef$horizontalS);
    (_affixRef$headerTopAf = affixRef.headerTopAffixRef.value) === null || _affixRef$headerTopAf === void 0 || (_affixRef$headerTopAf2 = _affixRef$headerTopAf.handleScroll) === null || _affixRef$headerTopAf2 === void 0 || _affixRef$headerTopAf2.call(_affixRef$headerTopAf);
    (_affixRef$footerBotto = affixRef.footerBottomAffixRef.value) === null || _affixRef$footerBotto === void 0 || (_affixRef$footerBotto2 = _affixRef$footerBotto.handleScroll) === null || _affixRef$footerBotto2 === void 0 || _affixRef$footerBotto2.call(_affixRef$footerBotto);
  };
  var calculateThWidthList = function calculateThWidthList(trList) {
    var widthMap = {};
    for (var i = 0, len = trList.length; i < len; i++) {
      var thList = trList[i].children;
      for (var j = 0, thLen = thList.length; j < thLen; j++) {
        var th = thList[j];
        var colKey = th.dataset.colkey;
        widthMap[colKey] = th.getBoundingClientRect().width;
      }
    }
    return widthMap;
  };
  var updateThWidthList = function updateThWidthList(trList) {
    if (trList instanceof HTMLCollection) {
      if (columnResizable.value) return;
      thWidthList.value = calculateThWidthList(trList);
    } else {
      thWidthList.value = thWidthList.value || {};
      Object.entries(trList).forEach(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
          colKey = _ref5[0],
          width = _ref5[1];
        thWidthList.value[colKey] = width;
      });
    }
    return thWidthList.value;
  };
  var updateThWidthListHandler = function updateThWidthListHandler() {
    var timer = setTimeout(function () {
      var _tableContentRef$valu2;
      updateTableWidth();
      if (notNeedThWidthList.value) return;
      var thead = (_tableContentRef$valu2 = tableContentRef.value) === null || _tableContentRef$valu2 === void 0 ? void 0 : _tableContentRef$valu2.querySelector("thead");
      if (!thead) return;
      updateThWidthList(thead.children);
      clearTimeout(timer);
    }, 0);
  };
  var resetThWidthList = function resetThWidthList() {
    thWidthList.value = {};
  };
  var emitScrollEvent = function emitScrollEvent(e) {
    var _props$onScrollX, _props$onScrollY, _props$onScroll;
    (_props$onScrollX = props.onScrollX) === null || _props$onScrollX === void 0 || _props$onScrollX.call(props, {
      e: e
    });
    (_props$onScrollY = props.onScrollY) === null || _props$onScrollY === void 0 || _props$onScrollY.call(props, {
      e: e
    });
    (_props$onScroll = props.onScroll) === null || _props$onScroll === void 0 || _props$onScroll.call(props, {
      e: e
    });
  };
  var getThWidthList = function getThWidthList(type) {
    if (type === "calculate") {
      var _tableContentRef$valu3;
      var trList = (_tableContentRef$valu3 = tableContentRef.value) === null || _tableContentRef$valu3 === void 0 || (_tableContentRef$valu3 = _tableContentRef$valu3.querySelector("thead")) === null || _tableContentRef$valu3 === void 0 ? void 0 : _tableContentRef$valu3.children;
      return calculateThWidthList(trList);
    }
    return thWidthList.value || {};
  };
  watch([data, columns, bordered, tableLayout, tableContentWidth, isFixedHeader, isWidthOverflow, isFixedColumn, fixedRows, firstFullRow, lastFullRow], updateFixedStatus, {
    immediate: true
  });
  watch([isFixedColumn, columns], function () {
    var timer = setTimeout(function () {
      if (isFixedColumn.value) {
        updateColumnFixedShadow(tableContentRef.value);
      }
      clearTimeout(timer);
    }, 0);
  }, {
    immediate: true
  });
  watch([maxHeight, data, columns, bordered, tableContentRef], function () {
    if (tableContentRef.value) {
      updateFixedHeader();
    }
  }, {
    immediate: true
  });
  watch(finalColumns, function () {
    resetThWidthList();
  });
  watch([data, bordered, tableLayout, fixedRows, isFixedHeader, headerAffixedTop, footerAffixedBottom, tableContentWidth], function () {
    var timer = setTimeout(function () {
      updateThWidthListHandler();
      updateAffixPosition();
      clearTimeout(timer);
    }, 60);
  }, {
    immediate: true
  });
  watch([finalColumns], function (_ref6, _ref7) {
    var _ref8 = _slicedToArray(_ref6, 1),
      finalColumns2 = _ref8[0];
    var _ref9 = _slicedToArray(_ref7, 1),
      preFinalColumns = _ref9[0];
    var finalColKeys = finalColumns2.map(function (t) {
      return t.colKey;
    });
    var preColKeys = preFinalColumns.map(function (t) {
      return t.colKey;
    });
    if (finalColKeys.length < preColKeys.length) {
      var reduceKeys = xorWith_1(preColKeys, finalColKeys);
      var thWidthList2 = getThWidthList("calculate");
      var reduceWidth = 0;
      reduceKeys.forEach(function (key) {
        reduceWidth += thWidthList2[key];
      });
      var rootThWidthList = pick_1(thWidthList2, preColKeys);
      var oldTotalWidth = Object.values(rootThWidthList).reduce(function () {
        var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var n = arguments.length > 1 ? arguments[1] : undefined;
        return r + n;
      });
      var contentWidth = tableContentRef.value.clientWidth;
      var widthToReserve = oldTotalWidth - reduceWidth;
      setTableElmWidth(Math.max(contentWidth, widthToReserve));
    }
  });
  var refreshTable = function refreshTable() {
    updateThWidthListHandler();
    updateFixedHeader();
    updateAffixPosition();
    if (isFixedColumn.value || isFixedHeader.value) {
      updateFixedStatus();
      updateColumnFixedShadow(tableContentRef.value, {
        skipScrollLimit: true
      });
    }
  };
  var onResize = debounce_1(function () {
    refreshTable();
  }, 30);
  var resizeObserver = null;
  function addTableResizeObserver(tableElement) {
    if (typeof window === "undefined") return;
    if (getIEVersion() < 11 || typeof window.ResizeObserver === "undefined") return;
    off(window, "resize", onResize);
    resizeObserver = new window.ResizeObserver(function () {
      var timer = setTimeout(function () {
        refreshTable();
        clearTimeout(timer);
      }, 200);
    });
    resizeObserver.observe(tableElement);
    tableRef.value = tableElement;
  }
  onMounted(function () {
    var scrollWidth = getScrollbarWidthWithCSS();
    scrollbarWidth.value = scrollWidth;
    updateThWidthListHandler();
    var isWatchResize = isFixedColumn.value || isFixedHeader.value || !notNeedThWidthList.value || !data.value.length;
    var hasWindow = typeof window !== "undefined";
    var hasResizeObserver = hasWindow && typeof window.ResizeObserver !== "undefined";
    if (isWatchResize && getIEVersion() < 11 || !hasResizeObserver) {
      on(window, "resize", onResize);
    }
  });
  onBeforeUnmount(function () {
    var _resizeObserver, _resizeObserver2;
    if (typeof window !== "undefined") {
      off(window, "resize", onResize);
    }
    (_resizeObserver = resizeObserver) === null || _resizeObserver === void 0 || _resizeObserver.unobserve(tableRef.value);
    (_resizeObserver2 = resizeObserver) === null || _resizeObserver2 === void 0 || _resizeObserver2.disconnect();
  });
  var setData = function setData(dataSource) {
    data.value = dataSource;
  };
  var updateTableAfterColumnResize = function updateTableAfterColumnResize() {
    updateFixedStatus();
    updateFixedHeader();
  };
  return {
    tableWidth: tableWidth,
    tableElmWidth: tableElmWidth,
    thWidthList: thWidthList,
    isFixedHeader: isFixedHeader,
    isWidthOverflow: isWidthOverflow,
    tableContentRef: tableContentRef,
    isFixedColumn: isFixedColumn,
    showColumnShadow: showColumnShadow,
    rowAndColFixedPosition: rowAndColFixedPosition,
    virtualScrollHeaderPos: virtualScrollHeaderPos,
    scrollbarWidth: scrollbarWidth,
    setData: setData,
    refreshTable: refreshTable,
    setTableElmWidth: setTableElmWidth,
    emitScrollEvent: emitScrollEvent,
    updateThWidthListHandler: updateThWidthListHandler,
    updateColumnFixedShadow: updateColumnFixedShadow,
    setUseFixedTableElmRef: setUseFixedTableElmRef,
    getThWidthList: getThWidthList,
    updateThWidthList: updateThWidthList,
    addTableResizeObserver: addTableResizeObserver,
    updateTableAfterColumnResize: updateTableAfterColumnResize
  };
}

export { useFixed as default, getColumnFixedStyles, getRowFixedStyles };
//# sourceMappingURL=useFixed.mjs.map
