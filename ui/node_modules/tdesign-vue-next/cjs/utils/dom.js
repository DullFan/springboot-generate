/**
 * tdesign v1.9.4
 * (c) 2024 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _commonjsHelpers = require('../_chunks/dep-4980a22e.js');
var isString = require('lodash/isString');
var isFunction = require('lodash/isFunction');
var isArray = require('lodash/isArray');
var utils_easing = require('./easing.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isString__default = /*#__PURE__*/_interopDefaultLegacy(isString);
var isFunction__default = /*#__PURE__*/_interopDefaultLegacy(isFunction);
var isArray__default = /*#__PURE__*/_interopDefaultLegacy(isArray);

var raf$2 = {exports: {}};

var performanceNow = {exports: {}};

// Generated by CoffeeScript 1.12.2
(function () {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    performanceNow.exports = function () {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    performanceNow.exports = function () {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function getNanoSeconds() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    performanceNow.exports = function () {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    performanceNow.exports = function () {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }
}).call(_commonjsHelpers.commonjsGlobal);

var now = performanceNow.exports,
  root = typeof window === 'undefined' ? _commonjsHelpers.commonjsGlobal : window,
  vendors = ['moz', 'webkit'],
  suffix = 'AnimationFrame',
  raf = root['request' + suffix],
  caf = root['cancel' + suffix] || root['cancelRequest' + suffix];
for (var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if (!raf || !caf) {
  var last = 0,
    id = 0,
    queue = [],
    frameDuration = 1000 / 60;
  raf = function raf(callback) {
    if (queue.length === 0) {
      var _now = now(),
        next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function () {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        var _loop = function _loop() {
          if (!cp[i].cancelled) {
            try {
              cp[i].callback(last);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          }
        };
        for (var i = 0; i < cp.length; i++) {
          _loop();
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id;
  };
  caf = function caf(handle) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}
raf$2.exports = function (fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn);
};
raf$2.exports.cancel = function () {
  caf.apply(root, arguments);
};
raf$2.exports.polyfill = function (object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
var raf$1 = raf$2.exports;

var isServer = typeof window === "undefined";
var trim = function trim(str) {
  return (str || "").replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, "");
};
var on = function () {
  if (!isServer && document.addEventListener) {
    return function (element, event, handler, options) {
      if (element && event && handler) {
        element.addEventListener(event, handler, options);
      }
    };
  }
  return function (element, event, handler) {
    if (element && event && handler) {
      element.attachEvent("on".concat(event), handler);
    }
  };
}();
var off = function () {
  if (!isServer && document.removeEventListener) {
    return function (element, event, handler, options) {
      if (element && event) {
        element.removeEventListener(event, handler, options);
      }
    };
  }
  return function (element, event, handler) {
    if (element && event) {
      element.detachEvent("on".concat(event), handler);
    }
  };
}();
function once(element, event, handler, options) {
  var handlerFn = isFunction__default["default"](handler) ? handler : handler.handleEvent;
  var callback = function callback(evt) {
    handlerFn(evt);
    off(element, event, callback, options);
  };
  on(element, event, callback, options);
}
function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(" ") !== -1) throw new Error("className should not contain space.");
  if (el.classList) {
    return el.classList.contains(cls);
  }
  return " ".concat(el.className, " ").indexOf(" ".concat(cls, " ")) > -1;
}
function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || "").split(" ");
  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;
    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += " ".concat(clsName);
    }
  }
  if (!el.classList) {
    el.className = curClass;
  }
}
function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(" ");
  var curClass = " ".concat(el.className, " ");
  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;
    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(" ".concat(clsName, " "), " ");
    }
  }
  if (!el.classList) {
    el.className = trim(curClass);
  }
}
var getAttach = function getAttach(node, triggerNode) {
  var attachNode = isFunction__default["default"](node) ? node(triggerNode) : node;
  if (!attachNode) {
    return document.body;
  }
  if (isString__default["default"](attachNode)) {
    return document.querySelector(attachNode);
  }
  if (attachNode instanceof HTMLElement) {
    return attachNode;
  }
  return document.body;
};
var getSSRAttach = function getSSRAttach() {
  if (process.env.NODE_ENV === "test-snap") return "body";
};
var getScrollContainer = function getScrollContainer() {
  var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "body";
  if (isString__default["default"](container)) {
    return document.querySelector(container);
  }
  if (isFunction__default["default"](container)) {
    return container();
  }
  return container;
};
function isWindow(obj) {
  return obj && obj === obj.window;
}
function getScroll(target, isLeft) {
  if (isServer || !target) {
    return 0;
  }
  var method = isLeft ? "scrollLeft" : "scrollTop";
  var result = 0;
  if (isWindow(target)) {
    result = target[isLeft ? "pageXOffset" : "pageYOffset"];
  } else if (target instanceof Document) {
    result = target.documentElement[method];
  } else if (target) {
    result = target[method];
  }
  return result;
}
function scrollTo(target, opt) {
  var _opt$container = opt.container,
    container = _opt$container === void 0 ? window : _opt$container,
    _opt$duration = opt.duration,
    duration = _opt$duration === void 0 ? 450 : _opt$duration,
    _opt$easing = opt.easing,
    easing = _opt$easing === void 0 ? utils_easing.easeInOutCubic : _opt$easing;
  var scrollTop = getScroll(container);
  var startTime = Date.now();
  return new Promise(function (res) {
    var fnc = function fnc() {
      var timestamp = Date.now();
      var time = timestamp - startTime;
      var nextScrollTop = easing(Math.min(time, duration), scrollTop, target, duration);
      if (isWindow(container)) {
        container.scrollTo(window.pageXOffset, nextScrollTop);
      } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
        container.documentElement.scrollTop = nextScrollTop;
      } else {
        container.scrollTop = nextScrollTop;
      }
      if (time < duration) {
        raf$1(fnc);
      } else {
        raf$1(res);
      }
    };
    raf$1(fnc);
  });
}
function containerDom(parent, child) {
  if (parent && child) {
    var pNode = child;
    while (pNode) {
      if (parent === pNode) {
        return true;
      }
      var _pNode = pNode,
        parentNode = _pNode.parentNode;
      pNode = parentNode;
    }
  }
  return false;
}
var clickOut = function clickOut(els, cb) {
  on(document, "click", function (event) {
    if (isArray__default["default"](els)) {
      var isFlag = Array.from(els).every(function (item) {
        return containerDom(item, event.target) === false;
      });
      return isFlag && cb && cb();
    }
    if (containerDom(els, event.target)) {
      return false;
    }
    return cb && cb();
  });
};
var isNodeOverflow = function isNodeOverflow(ele) {
  var _ele$clientWidth = ele.clientWidth,
    clientWidth = _ele$clientWidth === void 0 ? 0 : _ele$clientWidth,
    _ele$scrollWidth = ele.scrollWidth,
    scrollWidth = _ele$scrollWidth === void 0 ? 0 : _ele$scrollWidth;
  return scrollWidth > clientWidth;
};
var scrollSelectedIntoView = function scrollSelectedIntoView(parentEle, selected) {
  if (isServer) return;
  if (!selected || selected.offsetParent !== parentEle) {
    parentEle.scrollTop = 0;
    return;
  }
  var selectedTop = selected.offsetTop;
  var selectedBottom = selectedTop + selected.offsetHeight;
  var parentScrollTop = parentEle.scrollTop;
  var parentViewBottom = parentScrollTop + parentEle.clientHeight;
  if (selectedTop < parentScrollTop) {
    parentEle.scrollTop = selectedTop;
  } else if (selectedBottom > parentViewBottom) {
    parentEle.scrollTop = selectedBottom - parentEle.clientHeight;
  }
};
var requestSubmit = function requestSubmit(target) {
  if (!(target instanceof HTMLFormElement)) {
    throw new Error("target must be HTMLFormElement");
  }
  var submitter = document.createElement("input");
  submitter.type = "submit";
  submitter.hidden = true;
  target.appendChild(submitter);
  submitter.click();
  target.removeChild(submitter);
};
function elementInViewport(elm, parent) {
  var rect = elm.getBoundingClientRect();
  if (parent) {
    var parentRect = parent.getBoundingClientRect();
    return rect.top >= parentRect.top && rect.left >= parentRect.left && rect.bottom <= parentRect.bottom && rect.right <= parentRect.right;
  }
  return rect.top >= 0 && rect.left >= 0 && rect.bottom + 80 <= window.innerHeight && rect.right <= window.innerWidth;
}
function getElmCssPropValue(element, propName) {
  var propValue = "";
  if (document.defaultView && document.defaultView.getComputedStyle) {
    propValue = document.defaultView.getComputedStyle(element, null).getPropertyValue(propName);
  }
  if (propValue && propValue.toLowerCase) {
    return propValue.toLowerCase();
  }
  return propValue;
}
function isFixed(element) {
  var p = element.parentNode;
  if (!p || p.nodeName === "HTML") {
    return false;
  }
  if (getElmCssPropValue(element, "position") === "fixed") {
    return true;
  }
  return isFixed(p);
}
function getWindowScroll() {
  var _document = document,
    body = _document.body;
  var docElm = document.documentElement;
  var scrollTop = window.pageYOffset || docElm.scrollTop || body.scrollTop;
  var scrollLeft = window.pageXOffset || docElm.scrollLeft || body.scrollLeft;
  return {
    scrollTop: scrollTop,
    scrollLeft: scrollLeft
  };
}
function getWindowSize() {
  if (window.innerWidth !== void 0) {
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  }
  var doc = document.documentElement;
  return {
    width: doc.clientWidth,
    height: doc.clientHeight
  };
}
function getScrollbarWidth() {
  var scrollDiv = document.createElement("div");
  scrollDiv.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;";
  document.body.appendChild(scrollDiv);
  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
}

exports.addClass = addClass;
exports.clickOut = clickOut;
exports.elementInViewport = elementInViewport;
exports.getAttach = getAttach;
exports.getElmCssPropValue = getElmCssPropValue;
exports.getSSRAttach = getSSRAttach;
exports.getScroll = getScroll;
exports.getScrollContainer = getScrollContainer;
exports.getScrollbarWidth = getScrollbarWidth;
exports.getWindowScroll = getWindowScroll;
exports.getWindowSize = getWindowSize;
exports.hasClass = hasClass;
exports.isFixed = isFixed;
exports.isNodeOverflow = isNodeOverflow;
exports.isServer = isServer;
exports.off = off;
exports.on = on;
exports.once = once;
exports.removeClass = removeClass;
exports.requestSubmit = requestSubmit;
exports.scrollSelectedIntoView = scrollSelectedIntoView;
exports.scrollTo = scrollTo;
//# sourceMappingURL=dom.js.map
